// This file is auto-generated by @hey-api/openapi-ts

import { type Options, checkDockerStatus, getDockerOverview, getTopContainers, getPerformanceWarning, getLatestLog, listContainers, deleteContainer, getContainerDetails, getContainerLogs, startContainer, stopContainer, restartContainer, listDockerImages, listDockerVolumes, createDockerVolume, deleteDockerVolume, getContainerVolumes, getDockerNetworksOverview, getDockerNetworkMap, streamPullWithSummary, listDockerVolumesLite, attachVolumeToContainer, createContainerWithLogs, deleteDockerImage, deleteDockerNetwork, createDockerNetwork, assignNetworkToContainer, disconnectNetworkFromContainer, assignMultipleNetworksToContainer, assignNetworkWithStaticIp, listDockerNetworksLite } from '../sdk.gen';
import { queryOptions, type UseMutationOptions } from '@tanstack/react-query';
import type { CheckDockerStatusData, GetDockerOverviewData, GetTopContainersData, GetPerformanceWarningData, GetLatestLogData, ListContainersData, DeleteContainerData, DeleteContainerError, DeleteContainerResponse, GetContainerDetailsData, GetContainerLogsData, StartContainerData, StartContainerError, StartContainerResponse, StopContainerData, StopContainerError, StopContainerResponse, RestartContainerData, RestartContainerError, RestartContainerResponse, ListDockerImagesData, ListDockerVolumesData, CreateDockerVolumeData, CreateDockerVolumeError, CreateDockerVolumeResponse, DeleteDockerVolumeData, DeleteDockerVolumeError, DeleteDockerVolumeResponse, GetContainerVolumesData, GetDockerNetworksOverviewData, GetDockerNetworkMapData, StreamPullWithSummaryData, StreamPullWithSummaryError, ListDockerVolumesLiteData, AttachVolumeToContainerData, AttachVolumeToContainerError, AttachVolumeToContainerResponse, CreateContainerWithLogsData, CreateContainerWithLogsError, DeleteDockerImageData, DeleteDockerImageError, DeleteDockerImageResponse, DeleteDockerNetworkData, DeleteDockerNetworkError, DeleteDockerNetworkResponse, CreateDockerNetworkData, CreateDockerNetworkError, CreateDockerNetworkResponse, AssignNetworkToContainerData, AssignNetworkToContainerError, AssignNetworkToContainerResponse, DisconnectNetworkFromContainerData, DisconnectNetworkFromContainerError, DisconnectNetworkFromContainerResponse, AssignMultipleNetworksToContainerData, AssignMultipleNetworksToContainerError, AssignMultipleNetworksToContainerResponse, AssignNetworkWithStaticIpData, AssignNetworkWithStaticIpError, AssignNetworkWithStaticIpResponse, ListDockerNetworksLiteData } from '../types.gen';
import type { AxiosError } from 'axios';
import { client as _heyApiClient } from '../client.gen';

export type QueryKey<TOptions extends Options> = [
    Pick<TOptions, 'baseURL' | 'body' | 'headers' | 'path' | 'query'> & {
        _id: string;
        _infinite?: boolean;
    }
];

const createQueryKey = <TOptions extends Options>(id: string, options?: TOptions, infinite?: boolean): [
    QueryKey<TOptions>[0]
] => {
    const params: QueryKey<TOptions>[0] = { _id: id, baseURL: (options?.client ?? _heyApiClient).getConfig().baseURL } as QueryKey<TOptions>[0];
    if (infinite) {
        params._infinite = infinite;
    }
    if (options?.body) {
        params.body = options.body;
    }
    if (options?.headers) {
        params.headers = options.headers;
    }
    if (options?.path) {
        params.path = options.path;
    }
    if (options?.query) {
        params.query = options.query;
    }
    return [
        params
    ];
};

export const checkDockerStatusQueryKey = (options?: Options<CheckDockerStatusData>) => createQueryKey('checkDockerStatus', options);

/**
 * Check Docker Status
 */
export const checkDockerStatusOptions = (options?: Options<CheckDockerStatusData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await checkDockerStatus({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: checkDockerStatusQueryKey(options)
    });
};

export const getDockerOverviewQueryKey = (options?: Options<GetDockerOverviewData>) => createQueryKey('getDockerOverview', options);

/**
 * Get Docker Overview
 */
export const getDockerOverviewOptions = (options?: Options<GetDockerOverviewData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getDockerOverview({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getDockerOverviewQueryKey(options)
    });
};

export const getTopContainersQueryKey = (options?: Options<GetTopContainersData>) => createQueryKey('getTopContainers', options);

/**
 * Get Top Containers
 */
export const getTopContainersOptions = (options?: Options<GetTopContainersData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getTopContainers({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getTopContainersQueryKey(options)
    });
};

export const getPerformanceWarningQueryKey = (options?: Options<GetPerformanceWarningData>) => createQueryKey('getPerformanceWarning', options);

/**
 * Get Performance Warning
 */
export const getPerformanceWarningOptions = (options?: Options<GetPerformanceWarningData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getPerformanceWarning({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getPerformanceWarningQueryKey(options)
    });
};

export const getLatestLogQueryKey = (options?: Options<GetLatestLogData>) => createQueryKey('getLatestLog', options);

/**
 * Get Latest Log
 */
export const getLatestLogOptions = (options?: Options<GetLatestLogData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getLatestLog({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getLatestLogQueryKey(options)
    });
};

export const listContainersQueryKey = (options?: Options<ListContainersData>) => createQueryKey('listContainers', options);

/**
 * List Containers
 */
export const listContainersOptions = (options?: Options<ListContainersData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listContainers({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listContainersQueryKey(options)
    });
};

/**
 * Delete a Docker container by ID or name
 */
export const deleteContainerMutation = (options?: Partial<Options<DeleteContainerData>>): UseMutationOptions<DeleteContainerResponse, AxiosError<DeleteContainerError>, Options<DeleteContainerData>> => {
    const mutationOptions: UseMutationOptions<DeleteContainerResponse, AxiosError<DeleteContainerError>, Options<DeleteContainerData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteContainer({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getContainerDetailsQueryKey = (options: Options<GetContainerDetailsData>) => createQueryKey('getContainerDetails', options);

/**
 * Get Container Details
 */
export const getContainerDetailsOptions = (options: Options<GetContainerDetailsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getContainerDetails({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getContainerDetailsQueryKey(options)
    });
};

export const getContainerLogsQueryKey = (options: Options<GetContainerLogsData>) => createQueryKey('getContainerLogs', options);

/**
 * Get Container Logs
 */
export const getContainerLogsOptions = (options: Options<GetContainerLogsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getContainerLogs({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getContainerLogsQueryKey(options)
    });
};

export const startContainerQueryKey = (options: Options<StartContainerData>) => createQueryKey('startContainer', options);

/**
 * Start Container
 */
export const startContainerOptions = (options: Options<StartContainerData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await startContainer({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: startContainerQueryKey(options)
    });
};

/**
 * Start Container
 */
export const startContainerMutation = (options?: Partial<Options<StartContainerData>>): UseMutationOptions<StartContainerResponse, AxiosError<StartContainerError>, Options<StartContainerData>> => {
    const mutationOptions: UseMutationOptions<StartContainerResponse, AxiosError<StartContainerError>, Options<StartContainerData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await startContainer({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const stopContainerQueryKey = (options: Options<StopContainerData>) => createQueryKey('stopContainer', options);

/**
 * Stop Container
 */
export const stopContainerOptions = (options: Options<StopContainerData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await stopContainer({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: stopContainerQueryKey(options)
    });
};

/**
 * Stop Container
 */
export const stopContainerMutation = (options?: Partial<Options<StopContainerData>>): UseMutationOptions<StopContainerResponse, AxiosError<StopContainerError>, Options<StopContainerData>> => {
    const mutationOptions: UseMutationOptions<StopContainerResponse, AxiosError<StopContainerError>, Options<StopContainerData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await stopContainer({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const restartContainerQueryKey = (options: Options<RestartContainerData>) => createQueryKey('restartContainer', options);

/**
 * Restart Container
 */
export const restartContainerOptions = (options: Options<RestartContainerData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await restartContainer({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: restartContainerQueryKey(options)
    });
};

/**
 * Restart Container
 */
export const restartContainerMutation = (options?: Partial<Options<RestartContainerData>>): UseMutationOptions<RestartContainerResponse, AxiosError<RestartContainerError>, Options<RestartContainerData>> => {
    const mutationOptions: UseMutationOptions<RestartContainerResponse, AxiosError<RestartContainerError>, Options<RestartContainerData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await restartContainer({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listDockerImagesQueryKey = (options?: Options<ListDockerImagesData>) => createQueryKey('listDockerImages', options);

/**
 * List Docker Images
 */
export const listDockerImagesOptions = (options?: Options<ListDockerImagesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listDockerImages({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listDockerImagesQueryKey(options)
    });
};

export const listDockerVolumesQueryKey = (options?: Options<ListDockerVolumesData>) => createQueryKey('listDockerVolumes', options);

/**
 * List Docker Volumes
 */
export const listDockerVolumesOptions = (options?: Options<ListDockerVolumesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listDockerVolumes({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listDockerVolumesQueryKey(options)
    });
};

export const createDockerVolumeQueryKey = (options: Options<CreateDockerVolumeData>) => createQueryKey('createDockerVolume', options);

/**
 * Create a Docker volume and return metadata
 */
export const createDockerVolumeOptions = (options: Options<CreateDockerVolumeData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await createDockerVolume({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: createDockerVolumeQueryKey(options)
    });
};

/**
 * Create a Docker volume and return metadata
 */
export const createDockerVolumeMutation = (options?: Partial<Options<CreateDockerVolumeData>>): UseMutationOptions<CreateDockerVolumeResponse, AxiosError<CreateDockerVolumeError>, Options<CreateDockerVolumeData>> => {
    const mutationOptions: UseMutationOptions<CreateDockerVolumeResponse, AxiosError<CreateDockerVolumeError>, Options<CreateDockerVolumeData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await createDockerVolume({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete a Docker volume if not in use
 */
export const deleteDockerVolumeMutation = (options?: Partial<Options<DeleteDockerVolumeData>>): UseMutationOptions<DeleteDockerVolumeResponse, AxiosError<DeleteDockerVolumeError>, Options<DeleteDockerVolumeData>> => {
    const mutationOptions: UseMutationOptions<DeleteDockerVolumeResponse, AxiosError<DeleteDockerVolumeError>, Options<DeleteDockerVolumeData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteDockerVolume({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getContainerVolumesQueryKey = (options: Options<GetContainerVolumesData>) => createQueryKey('getContainerVolumes', options);

/**
 * Get Container Volumes
 */
export const getContainerVolumesOptions = (options: Options<GetContainerVolumesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getContainerVolumes({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getContainerVolumesQueryKey(options)
    });
};

export const getDockerNetworksOverviewQueryKey = (options?: Options<GetDockerNetworksOverviewData>) => createQueryKey('getDockerNetworksOverview', options);

/**
 * Get Docker Networks Overview
 */
export const getDockerNetworksOverviewOptions = (options?: Options<GetDockerNetworksOverviewData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getDockerNetworksOverview({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getDockerNetworksOverviewQueryKey(options)
    });
};

export const getDockerNetworkMapQueryKey = (options?: Options<GetDockerNetworkMapData>) => createQueryKey('getDockerNetworkMap', options);

/**
 * Get Docker Network Node Map
 */
export const getDockerNetworkMapOptions = (options?: Options<GetDockerNetworkMapData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getDockerNetworkMap({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getDockerNetworkMapQueryKey(options)
    });
};

export const streamPullWithSummaryQueryKey = (options: Options<StreamPullWithSummaryData>) => createQueryKey('streamPullWithSummary', options);

/**
 * Stream Docker image pull with progress and summary
 */
export const streamPullWithSummaryOptions = (options: Options<StreamPullWithSummaryData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await streamPullWithSummary({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: streamPullWithSummaryQueryKey(options)
    });
};

/**
 * Stream Docker image pull with progress and summary
 */
export const streamPullWithSummaryMutation = (options?: Partial<Options<StreamPullWithSummaryData>>): UseMutationOptions<unknown, AxiosError<StreamPullWithSummaryError>, Options<StreamPullWithSummaryData>> => {
    const mutationOptions: UseMutationOptions<unknown, AxiosError<StreamPullWithSummaryError>, Options<StreamPullWithSummaryData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await streamPullWithSummary({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listDockerVolumesLiteQueryKey = (options?: Options<ListDockerVolumesLiteData>) => createQueryKey('listDockerVolumesLite', options);

/**
 * List all Docker volumes with ID and name
 */
export const listDockerVolumesLiteOptions = (options?: Options<ListDockerVolumesLiteData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listDockerVolumesLite({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listDockerVolumesLiteQueryKey(options)
    });
};

export const attachVolumeToContainerQueryKey = (options: Options<AttachVolumeToContainerData>) => createQueryKey('attachVolumeToContainer', options);

/**
 * Attach a volume to a stopped container and recreate it
 */
export const attachVolumeToContainerOptions = (options: Options<AttachVolumeToContainerData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await attachVolumeToContainer({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: attachVolumeToContainerQueryKey(options)
    });
};

/**
 * Attach a volume to a stopped container and recreate it
 */
export const attachVolumeToContainerMutation = (options?: Partial<Options<AttachVolumeToContainerData>>): UseMutationOptions<AttachVolumeToContainerResponse, AxiosError<AttachVolumeToContainerError>, Options<AttachVolumeToContainerData>> => {
    const mutationOptions: UseMutationOptions<AttachVolumeToContainerResponse, AxiosError<AttachVolumeToContainerError>, Options<AttachVolumeToContainerData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await attachVolumeToContainer({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const createContainerWithLogsQueryKey = (options: Options<CreateContainerWithLogsData>) => createQueryKey('createContainerWithLogs', options);

/**
 * Create a Docker container and stream progress logs
 */
export const createContainerWithLogsOptions = (options: Options<CreateContainerWithLogsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await createContainerWithLogs({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: createContainerWithLogsQueryKey(options)
    });
};

/**
 * Create a Docker container and stream progress logs
 */
export const createContainerWithLogsMutation = (options?: Partial<Options<CreateContainerWithLogsData>>): UseMutationOptions<unknown, AxiosError<CreateContainerWithLogsError>, Options<CreateContainerWithLogsData>> => {
    const mutationOptions: UseMutationOptions<unknown, AxiosError<CreateContainerWithLogsError>, Options<CreateContainerWithLogsData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await createContainerWithLogs({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete a Docker image by ID or tag
 */
export const deleteDockerImageMutation = (options?: Partial<Options<DeleteDockerImageData>>): UseMutationOptions<DeleteDockerImageResponse, AxiosError<DeleteDockerImageError>, Options<DeleteDockerImageData>> => {
    const mutationOptions: UseMutationOptions<DeleteDockerImageResponse, AxiosError<DeleteDockerImageError>, Options<DeleteDockerImageData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteDockerImage({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete a Docker network by ID or name, only if no containers are attached
 */
export const deleteDockerNetworkMutation = (options?: Partial<Options<DeleteDockerNetworkData>>): UseMutationOptions<DeleteDockerNetworkResponse, AxiosError<DeleteDockerNetworkError>, Options<DeleteDockerNetworkData>> => {
    const mutationOptions: UseMutationOptions<DeleteDockerNetworkResponse, AxiosError<DeleteDockerNetworkError>, Options<DeleteDockerNetworkData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteDockerNetwork({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const createDockerNetworkQueryKey = (options: Options<CreateDockerNetworkData>) => createQueryKey('createDockerNetwork', options);

/**
 * Create a Docker network
 */
export const createDockerNetworkOptions = (options: Options<CreateDockerNetworkData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await createDockerNetwork({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: createDockerNetworkQueryKey(options)
    });
};

/**
 * Create a Docker network
 */
export const createDockerNetworkMutation = (options?: Partial<Options<CreateDockerNetworkData>>): UseMutationOptions<CreateDockerNetworkResponse, AxiosError<CreateDockerNetworkError>, Options<CreateDockerNetworkData>> => {
    const mutationOptions: UseMutationOptions<CreateDockerNetworkResponse, AxiosError<CreateDockerNetworkError>, Options<CreateDockerNetworkData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await createDockerNetwork({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const assignNetworkToContainerQueryKey = (options: Options<AssignNetworkToContainerData>) => createQueryKey('assignNetworkToContainer', options);

/**
 * Assign a Docker network to a container
 */
export const assignNetworkToContainerOptions = (options: Options<AssignNetworkToContainerData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await assignNetworkToContainer({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: assignNetworkToContainerQueryKey(options)
    });
};

/**
 * Assign a Docker network to a container
 */
export const assignNetworkToContainerMutation = (options?: Partial<Options<AssignNetworkToContainerData>>): UseMutationOptions<AssignNetworkToContainerResponse, AxiosError<AssignNetworkToContainerError>, Options<AssignNetworkToContainerData>> => {
    const mutationOptions: UseMutationOptions<AssignNetworkToContainerResponse, AxiosError<AssignNetworkToContainerError>, Options<AssignNetworkToContainerData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await assignNetworkToContainer({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const disconnectNetworkFromContainerQueryKey = (options: Options<DisconnectNetworkFromContainerData>) => createQueryKey('disconnectNetworkFromContainer', options);

/**
 * Disconnect a Docker network from a container
 */
export const disconnectNetworkFromContainerOptions = (options: Options<DisconnectNetworkFromContainerData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await disconnectNetworkFromContainer({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: disconnectNetworkFromContainerQueryKey(options)
    });
};

/**
 * Disconnect a Docker network from a container
 */
export const disconnectNetworkFromContainerMutation = (options?: Partial<Options<DisconnectNetworkFromContainerData>>): UseMutationOptions<DisconnectNetworkFromContainerResponse, AxiosError<DisconnectNetworkFromContainerError>, Options<DisconnectNetworkFromContainerData>> => {
    const mutationOptions: UseMutationOptions<DisconnectNetworkFromContainerResponse, AxiosError<DisconnectNetworkFromContainerError>, Options<DisconnectNetworkFromContainerData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await disconnectNetworkFromContainer({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const assignMultipleNetworksToContainerQueryKey = (options: Options<AssignMultipleNetworksToContainerData>) => createQueryKey('assignMultipleNetworksToContainer', options);

/**
 * Assign multiple Docker networks to a container
 */
export const assignMultipleNetworksToContainerOptions = (options: Options<AssignMultipleNetworksToContainerData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await assignMultipleNetworksToContainer({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: assignMultipleNetworksToContainerQueryKey(options)
    });
};

/**
 * Assign multiple Docker networks to a container
 */
export const assignMultipleNetworksToContainerMutation = (options?: Partial<Options<AssignMultipleNetworksToContainerData>>): UseMutationOptions<AssignMultipleNetworksToContainerResponse, AxiosError<AssignMultipleNetworksToContainerError>, Options<AssignMultipleNetworksToContainerData>> => {
    const mutationOptions: UseMutationOptions<AssignMultipleNetworksToContainerResponse, AxiosError<AssignMultipleNetworksToContainerError>, Options<AssignMultipleNetworksToContainerData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await assignMultipleNetworksToContainer({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const assignNetworkWithStaticIpQueryKey = (options: Options<AssignNetworkWithStaticIpData>) => createQueryKey('assignNetworkWithStaticIp', options);

/**
 * Assign a Docker network to a container with optional static IP
 */
export const assignNetworkWithStaticIpOptions = (options: Options<AssignNetworkWithStaticIpData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await assignNetworkWithStaticIp({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: assignNetworkWithStaticIpQueryKey(options)
    });
};

/**
 * Assign a Docker network to a container with optional static IP
 */
export const assignNetworkWithStaticIpMutation = (options?: Partial<Options<AssignNetworkWithStaticIpData>>): UseMutationOptions<AssignNetworkWithStaticIpResponse, AxiosError<AssignNetworkWithStaticIpError>, Options<AssignNetworkWithStaticIpData>> => {
    const mutationOptions: UseMutationOptions<AssignNetworkWithStaticIpResponse, AxiosError<AssignNetworkWithStaticIpError>, Options<AssignNetworkWithStaticIpData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await assignNetworkWithStaticIp({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listDockerNetworksLiteQueryKey = (options?: Options<ListDockerNetworksLiteData>) => createQueryKey('listDockerNetworksLite', options);

/**
 * List Docker networks for dropdown selection
 */
export const listDockerNetworksLiteOptions = (options?: Options<ListDockerNetworksLiteData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listDockerNetworksLite({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listDockerNetworksLiteQueryKey(options)
    });
};